# Section 1

- section.1 강의를 듣고 배운 내용과 느낀 점등을 적는 MarkDown 입니다.

<br>

### next 프로젝트 시작하는 법

1. CMD `npx create-next-app@latest` 명령어를 사용하여 최신 next 버전을 설치하여 사용할 수 있습니다.

2. 프로젝트 명을 입력하여 사용합니다. EX: k.com

3. 프로젝트에 사용 될 옵션을 체크 합니다. 

```
- TypeScript: TS 사용 유무 체크

- ESLint: 문제 패턴 식별 도구 사용 여부 체크

- Tailwind css: Tailwind css 사용 유무 체크

- `src/directory`: src 디렉토리 사용 유무 체크

- App Router: App router 사용 유무 체크

- import alias: 전역 import 커스텀 유무 체크 (default = "@", EX: ~ , * )
```

<br>

### 브라우저 주소를 app 폴더에 반영하기

1. x.com 사이트를 "로그인 후" 사용해보면 url을 이동하여도 왼쪽 & 오른쪽 레이아웃이 변경되지 않는 것을 확인 할 수 있다.
  
  - RootLayout: next 13 버전에서 도입 된 레이아웃, 최상위 레이아웃이라고 하며 모든 Page에 적용이 됩니다. 
  
  - 어떻게? : page 컴포넌트를 children Prop으로 받기 때문! => page 가 RootLayout에 포함이 되는 것을 알 수 있습니다.
  
  - 예외 상황?: 모든 컴포넌트에 적용하고 싶지는 않을 때 (EX: 로그인 되지 않은 x.com 화면) => 폴더 구조를 분할하여 해결할 수 있습니다. 새로운 폴더 생성 => home/page.tsx 이 또한 RootLayout을 적용 받는 상황 이지만 home 폴더에 layout.tsx 를 만들어 작성하였을 때 RootLayout이 아닌 home/layout.tsx가 적용이 됩니다.

<br>

2. username을 url parameter 로 가지는 경우 user가 생성 될 때 마다 파일을 하나씩 추가하는 방식은 비효율적입니다.

  - Dynamic Routing(slug): [] 대괄호 기호를 사용하여 폴더를 생성할 시 동적 라우팅을 제공합니다. [username] 폴더의 경우 어떤 유저의 이름을 받았을 경우 url parameter에 적용 됩니다.  게시글의 id의 경우에도 [id] 폴더 등의 생성으로 진행할 수 있습니다.

  - not-found.tsx: 존재하지 않는 경로에 사용자가 접근하였을 때 출력 되는 컴포넌트 입니다. src 하위에 작성 가능합니다.

<br>

### 라우트 그룹

1. RootLayout에 어떤 것을 적용해야 할지 고민이 될 수 있습니다.

  - 만들 웹의 Layout을 큰 틀에서 구분 할 수 있어야 합니다. x.com의 레이아웃의 경우 크게 "로그인 전", "로그인 후"로 레이아웃이 나뉘게 됩니다.

  - (FolderName) 그룹화: () 소괄호 기호를 사용하여 폴더를 생성하여 큰 틀을 나눕니다. 소괄호를 사용하여 폴더명을 작성하였을 경우 주소 창에 영향을 끼치지 않습니다. (afterLogin) & (beforeLogin) 으로 나누어 로그인 전에 보여질 컴포넌트와 후에 보여질 컴포넌트를 분할하여 작성할 수 있습니다. 

  - (beforLogin) & (afterLogin)의 하위에 layout.tsx를 작성하여 로그인 전과 후에 적용 될 레이아웃을 작성할 수 있습니다. 초기 폴더 구조를 잘 생각하여 작성 시 간단하게 그룹화 할 수 있습니다.

<br>

### template.tsx, Link, Image, redirect

1. 페이지를 넘나들 때 페이지는 리렌더링 되지만 레이아웃의 경우 리렌더링 되지 않습니다.

  - 리렌더링 되게하고 싶어요!: template.tsx를 작성하여 구현할 수 있습니다. 공식문서의 경우 페이지를 넘나들때 마다 특정 기록을 하는 경우 등에 template.tsx를 사용할 수 있다고 되어 있습니다. template과 layout은 공존 할 수 없기 때문에 필요에 따라 작성 할 수 있습니다.

  - Link: next 에서 a 태그가 아닌 Link를 사용합니다. a 태그의 경우 페이지가 새로고침 되면서 리렌더링 되기 떄문에 리액트와 next에서 이러한 동작이 발생하는 것은 비효율적 이기에 Link를 사용합니다.  (html 구조가 변경될 경우 그 부분만 리렌더링 => React)

  - Image: png 파일을 import하여 사용이 가능합니다.  img 태그가 아닌 Image로 사용해야 하고 next에서 기본으로 최적화를 해주는 장점이 있습니다.

  - redirect: next/navigation 에서 제공합니다. 특정 페이지로 이동 시 redirect 할 수 있습니다.

<br>

### 패러렐 라우트

1. 뒤의 화면이 남아있으면서 url을 이동하고 싶을 때? 패러렐 라우트 & 인터셉트 라우트를 사용하여 구현할 수 있습니다. 일반적으로 Modal 창의 경우 url이 이동하지는 않지만, x.com의 경우 로그인 또는 계정 생성을 클릭하였을 경우 form Modal 이 뜨면서 url도 변경 됩니다.

  - 바탕 (beforeLogin)/page.tsx를 띄우면서 i/flow/login/page.tsx(Modal)을 띄위기위해 @modal 폴더를 생성해줍니다. @ 패러렐 라우트를 사용하는 경우 같은 경로 상에 있지 않으면 적용 되지 않기 때문에 같은 폴더 위치를 동일한 경로 상에 위치하도록 해야 합니다.

  - children 의 타입을 설정해주지 않으면 타입 에러가 발생하기 때문에 적용해주어야 합니다. children의 경우 ReactNode 타입을 가지며 레이아웃에서 구조 분해 할당 된 매개변수로 받습니다. 여러개를 받을 경우 type Props 등으로 객체를 생성 하여 할당할 수 있습니다.

  - RootLayout에서 modal을 import 하여 사용이 가능합니다. => 두 개의 Page 를 동시에 출력 가능

<br>

### 클라이언트 컴포넌트로 전환

1. next의 컴포넌트는 기본적으로 서버 컴포넌트이기 때문에 16.8 버전 Hooks를 사용할 수가 없습니다. 서버 컴포넌트이기 때문에 컴포넌트를 비동기로도 작성이 가능합니다. => EX: export default async function Layout(){}

  - "use client" 를 최상단에 작성하는 것으로 간단하게 클라이언트 컴포넌트로 변경이 가능합니다. => "use strict" 엄격 모드 사용 하듯 사용 가능

  - 클라이언트 컴포넌트("use client")도 서버에서 렌더링이 됩니다. => SSR 가능

<br>

### default.tsx

1. 현재 상황은 @/(beforeLogin)/Main 에서 두 개의 페이지가 출력 되고 있는 상황. => 메인에서 로그인 또는 계정 생성을 클릭하였을 때, 메인은 계속해서 출력 되야 하고 url 주소는 변경이 되어야 합니다 "i/flow/login" , "i/flow/singup"

  - @modal 파일 안에 i/flow/login으로 컴포넌트를 만든 후 login.modal.css와 page.tsx를 그대로 집어 넣었으나 기존의 page.tsx가 사라지는 문제가 발생합니다. => 404가 뜸

  - @modal 하위에 page.tsx를 작성하는 것이 아닌 default.tsx 파일을 만들어 해결이 가능합니다.  패러렐 라우트에 대한 기본 값을 제공 합니다 =>
  (return null; 작성으로 해결 가능)

  - 주소가 메인(localhost:3000)에 있을 경우 RootLayout의 children은 page.tsx modal의 경우 @modal/default.tsx 가 됩니다.
  
  - 주소가 "메인/i/flow/login" 의 경우 RootLayout의 children은 "i/flow/login/page.tsx" modal의 경우 "@modal/i/flow/login/page.tsx" 가 됩니다.

<br>

### 인터셉팅 라우트

1. 로그인 창이 뜨기는 하지만 뒤의 Main 배경이 출력 되지 않는 상태 => 이제 패러렐 라우팅의 역할은 끝, 인터셉팅 라우팅이 필요한 차례!

  - 인터셉팅 라우팅은 서로 다른 주소를 가지고 있지만 같이 띄울 수 있는 것을 말합니다. 

  - (..)i => ..은 부모 컴포넌트를 말합니다 (..)이나 (.)은 브라우저 주소를 기준으로 작동합니다. (beforeLogin)/@modal 에서 (..)i 폴더를 생성 시 (beforeLogin)의 상위인 app으로 이동합니다.
  
  - @의 경우 주소에 영향을 끼치지 않기 때문에 무시합니다. (우리 눈에만 보인다고 생각하면 될듯)

  -  i/login/page.tsx 대체를 위해 @modal/(.)i로 파일 이름을 변경 해줍니다. 이렇게 하면 클라이언트에서 라우팅 할 때만 인터셉트 라우팅이 적용되게 됩니다. 

<br>

### private folder

1. 중복되는 코드를 정리하기 위하여 private folder를 생성하여 관리할 수 있습니다.

  - 폴더 명 앞에 _를 붙여 생성이 가능합니다. EX: _component/Main.tsx (공통 Page 컴포넌트) & login.module.css (공통 css) 

  - 서버 컴포넌트에서 클라이언트 컴포넌트를 import 할 수 있습니다. 하지만 역으로는 할 수 없습니다.

  - 가능은 하지만 클라이언트 컴포넌트가 서버 컴포넌트를 import하게 되면 서버 컴포넌트가 클라이언트 컴포넌트로 변경 되어 버리는 문제가 발생합니다.

<br>

### section1 느낀점

- next 프레임워크를 사용할 떄 폴더 구조를 명확하게 구분하고 작성할 줄 알아야 한다는 점을 알 수 있었습니다. 좋은 코드를 작성하기 위해 그룹화를 하는 것은 필수적인 선택이지만, 프레임워크를 사용할 때에는 그 기준에 맞춰 작성할 수 있도록 하여야 합니다. 

- 아직 익숙하지는 않지만 프로젝트를 만들 때 큰 틀을 두고 생각해야할 필요성을 느꼈습니다. 많이 작성하는 수 밖에 없을 것 같습니다(프레임워크를 사용하는 이상).

- 14버전이 기본적으로 오류가 많은 편인지 아니면 캐싱이 잘못 되어 있기 떄문에 그런건지 바로 적용되지 않는 경우가 많았습니다. 터미널을 확인하여 상태 코드가 200 임에도 수정 사항이 적용되지 않았다면 재실행 하여 해결하기는 하였습니다. 

- 코드를 작성한 후 문제가 있을 경우 내 코드에 문제가 있나? 라는 생각보다 터미널을 먼저 확인하고 재실행을 우선 해보는 것이 시간을 효율적으로 활용하는 방법이 될 수도 있겠다고 생각하였습니다. 
